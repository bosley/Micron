use std::str::FromStr;
use crate::ast::{Expr, Opcode, Statement, FLOAT_PRECISION}; // (0)
use rug;
use rug::Assign;

grammar;

pub Program: Vec<Box<Statement>> = {

    // Accept multiple statements
    Statements+ => <>
}

// All of the types of statements within the language
Statements: Box<Statement> = {

    <a:AssignmentStatement> => a,
    <b:BareExpressionStatement> => b
}

// Assignment statement 
AssignmentStatement: Box<Statement> = {

    "let" <v:Variable> "=" <e:Expr> ";" => Box::new(Statement::Assignment(v,e)),
}

// Bare Expression
BareExpressionStatement: Box<Statement> = {

    <e:Expr> => Box::new(Statement::BareExpression(e))
}

// Expression
Expr: Box<Expr> = { // (1)
    Expr ExprOp Factor => Box::new(Expr::Op(<>)), // (2)
    Factor,
};

ExprOp: Opcode = { // (3)
    "+"  => Opcode::Add,
    "-"  => Opcode::Sub,
    "<=" => Opcode::Lte,
    ">=" => Opcode::Gte,
    ">"  => Opcode::Gt,
    "<"  => Opcode::Lt,
    "==" => Opcode::Equal,
    "!=" => Opcode::Ne
};

Factor: Box<Expr> = {
    Factor FactorOp Term => Box::new(Expr::Op(<>)),
    Term,
};

FactorOp: Opcode = {
    "*"   => Opcode::Mul,
    "/"   => Opcode::Div,
    "**" => Opcode::Pow,
    "%"   => Opcode::Mod,
    "<<"  => Opcode::Lsh,
    ">>"  => Opcode::Rsh,
    "^"   => Opcode::BwXor,
    "|"   => Opcode::BwOr,
    "&"   => Opcode::BwAnd,
    "||"  => Opcode::Or,
    "&&"  => Opcode::And
};

Term: Box<Expr> = {
    Integer => Box::new(Expr::Number(<>)),
    Float   => Box::new(Expr::Real(<>)),
    Variable => Box::new(Expr::Variable(<>)),
    "(" <Expr> ")"
};

Integer: rug::Integer = {
    r"(\-)?[0-9]+" => {

        let mut int = rug::Integer::new();
        int.assign(rug::Integer::parse(<>).unwrap());
        int
    }
};

Float: rug::Float = {
    r"(\-)?[0-9]+\.[0-9]+" => {

        let mut int = rug::Float::new(FLOAT_PRECISION);
        int.assign(rug::Float::parse(<>).unwrap());
        int
    }
}

Variable: String = {
    r"[a-zA-Z_]+([0-9]+)?" => String::from_str(<>).unwrap()
};