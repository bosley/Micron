use std::str::FromStr;
use rug;
use rug::Assign;

use micron_ast::{
    Expr, Opcode, UnaryOpcode, Statement, FLOAT_PRECISION, Accessors, MemberMethod, DictEntry
};

grammar;

pub Program: Vec<Box<Statement>> = {

    // Accept multiple statements
    Statements+ => <>
}

// All of the types of statements within the language
Statements: Box<Statement> = {

    <a:AssignmentStatement> => a,
    <b:BareExpressionStatement> => b,
}

// Assignment statement 
AssignmentStatement: Box<Statement> = {

    <v:Variable> "=" <e:Expr>   => Box::new(Statement::Assignment(v, e)),
}

// Bare Expression
BareExpressionStatement: Box<Statement> = {

    <e:Expr> => Box::new(Statement::BareExpression(e)),
    <b:BuiltInFunction> => Box::new(Statement::BareExpression(b))
}

// Expression
Expr: Box<Expr> = {
    Expr ExprOp Factor => Box::new(Expr::Op(<>)),
    Factor,
    "!" <f:Factor> => Box::new(Expr::UnaryOp(f, UnaryOpcode::Negate)),
    "~" <f:Factor> => Box::new(Expr::UnaryOp(f, UnaryOpcode::BwNot)),
};

Access: Accessors = {
    "."  => Accessors::Dot
}

ExprOp: Opcode = { // (3)
    "+"  => Opcode::Add,
    "-"  => Opcode::Sub,
    "<=" => Opcode::Lte,
    ">=" => Opcode::Gte,
    ">"  => Opcode::Gt,
    "<"  => Opcode::Lt,
    "==" => Opcode::Equal
};

Factor: Box<Expr> = {
    Factor FactorOp Term => Box::new(Expr::Op(<>)),
    Term Access Method => Box::new(Expr::Access(<>)),
    Term,
};

FactorOp: Opcode = {
    "*"   => Opcode::Mul,
    "/"   => Opcode::Div,
    "**"  => Opcode::Pow,
    "%"   => Opcode::Mod,
    "<<"  => Opcode::Lsh,
    ">>"  => Opcode::Rsh,
    "^"   => Opcode::BwXor,
    "|"   => Opcode::BwOr,
    "&"   => Opcode::BwAnd,
    "||"  => Opcode::Or,
    "&&"  => Opcode::And
};

Term: Box<Expr> = {
    Integer   => Box::new(Expr::Number(<>)),
    Float     => Box::new(Expr::Real(<>)),
    VarTerm,
    DictTerm,
    String    => Box::new(Expr::String(<>)),
    "(" <Expr> ")",
};

VarTerm: Box<Expr> = {

    Variable  => Box::new(Expr::Variable(<>)),
    <v:Variable> <d:DictAccessor+> => Box::new(Expr::VarDict(v, d))
}

DictAccessor: String = {
    "[" <k:DictKey> "]" => k
}

DictTerm: Box<Expr> = {

    "{" "}" => Box::new(Expr::Dict(Vec::new())),
    "{" <v:Multiples<",", DictionaryEntry>> "}" => Box::new(Expr::Dict(v))
}

DictionaryEntry: Box<DictEntry> = {

    <s:String> ":" <e:Expr> => Box::new(DictEntry{
                                        key: s,
                                        value: e
                                    })
}

Method: Box<MemberMethod> = {
    <f:Function> "(" ")" => Box::new(MemberMethod{
        method: f,
        params: Vec::new()
    }),
    <f:Function> "(" <c:CallParams> ")" => Box::new(MemberMethod{
        method: f,
        params: c
    })
}

CallParams: Vec<Box<Expr>> = {
    <v:Multiples<",", Expr>> => <>
}

BuiltInFunction: Box<Expr> = {

    "$" <f:Function> "(" <v:Multiples<",", Variable>> ")" => Box::new(Expr::Modifier(f, v))
}

Integer: rug::Integer = {
    r"(\-)?[0-9]+" => {

        let mut value = rug::Integer::new();
        value.assign(rug::Integer::parse(<>).unwrap());
        value
    }
};

Float: rug::Float = {
    r"(\-)?[0-9]+\.[0-9]+" => {

        let mut value = rug::Float::new(FLOAT_PRECISION);
        value.assign(rug::Float::parse(<>).unwrap());
        value
    }
}

String: String = {
    r#""([^"\\]|\\[0nrt"\\])*""# => String::from(<>.trim_matches('"'))
}

Function: String = {
    r"[a-zA-Z_]+([0-9]+)?" => String::from_str(<>).unwrap()
}

Variable: String = {
    r"[a-zA-Z_]+([0-9]+)?" => String::from_str(<>).unwrap()
};

DictKey: String = {
    r"'[a-zA-Z_]+([0-9]+)?'"=> String::from_str(<>.trim_matches('\'')).unwrap()
}

// Get multiples of types sep by string 'V' 
Multiples<V, T>: Vec<T> = {
    <v:(<T> V)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    },
};
